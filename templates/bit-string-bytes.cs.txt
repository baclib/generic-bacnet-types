/// <summary>
/// Represents the bit string {{BACNET_NAME}} as defined in ANSI/ASHRAE 135-2024 Clause 20.6.
/// </summary>
public readonly record struct {{TYPE_NAME}} : IReadOnlyCollection<bool>
{
    /// <summary>
    /// Underlying storage for the bits, represented as an array of bytes in system-native format.
    /// </summary>
    private readonly byte[] _bytes = BitString.EmptyData;

    /// <summary>
    /// Minimum number of bits required for this type.
    /// </summary>
    public const int MinCount = {{MINIMUM_BIT_COUNT}};

    /// <summary>
    /// Maximum number of bits allowed for this type.
    /// </summary>
    public const int MaxCount = {{MAXIMUM_BIT_COUNT}};

    /// <summary>
    /// Initializes a new instance of <see cref="ServicesSupported"/> from a span of bytes.
    /// </summary>
    /// <param name="bytes">
    /// The source bytes containing the bit data. The span must be at least <c>(count + 7) / 8</c> bytes long.
    /// Only the minimum required number of bytes are copied, and any excess bytes in the span are ignored.
    /// </param>
    /// <param name="count">Number of bits used by this instance (range <see cref="MinCount"/>..<see cref="MaxCount"/>).</param>
    /// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="count"/> is outside the allowed range.</exception>
    /// <exception cref="ArgumentException">Thrown when <paramref name="bytes"/> is shorter than required for <paramref name="count"/>.</exception>
    public {{TYPE_NAME}}(ReadOnlySpan<byte> bytes, int count = MinCount)
    {
        ArgumentOutOfRangeException.ThrowIfLessThan(count, MinCount, nameof(count));
        ArgumentOutOfRangeException.ThrowIfGreaterThan(count, MaxCount, nameof(count));

        int minimumLength = (count + 7) / 8;
        if (bytes.Length < minimumLength)
        {
            throw new ArgumentException($"Too short for {count} bits.", nameof(bytes));
        }

        _bytes = bytes[..minimumLength].ToArray();
        Count = count;
    }

{{ITEMS}}

    /// <summary>
    /// Gets the boolean value of the bit at the specified zero-based <paramref name="index"/>.
    /// </summary>
    /// <param name="index">Zero-based bit index.</param>
    /// <returns><see langword="true"/> if the bit is set; otherwise <see langword="false"/>.</returns>
    /// <exception cref="ArgumentOutOfRangeException">
    /// Thrown when <paramref name="index"/> is less than 0 or greater than or equal to <see cref="Count"/>.
    /// </exception>
    public bool this[int index]
    {
        get
        {
            ArgumentOutOfRangeException.ThrowIfNegative(index, nameof(index));
            ArgumentOutOfRangeException.ThrowIfGreaterThanOrEqual(index, Count, nameof(index));

            return _bytes[index / 8].GetBit(index % 8);
        }
    }

    /// <summary>
    /// Gets the number of bits used by this instance.
    /// </summary>
    public int Count { get; }

    /// <summary>
    /// Returns a value-type enumerator suitable for pattern-based foreach iteration.
    /// Use this when iterating the struct directly to avoid allocations/boxing.
    /// </summary>
    public Enumerator GetEnumerator() => new(this);

    /// <summary>
    /// Value-type enumerator used by the public pattern-based <see cref="GetEnumerator"/> method.
    /// </summary>
    /// <remarks>
    /// The enumerator is a struct so direct iteration over a <see cref="{{TYPE_NAME}}"/> value does not allocate.
    /// As is standard .NET practice, no range checks are performed in <see cref="Current"/>. The consumer must
    /// call <see cref="MoveNext"/> and only access <see cref="Current"/> when it is valid.
    /// </remarks>
    public struct Enumerator
    {
        /// <summary>
        /// Copy of the parent <see cref="{{TYPE_NAME}}"/> instance being enumerated.
        /// </summary>
        private readonly {{TYPE_NAME}} _bits;

        /// <summary>
        /// Current enumerator index. Starts at -1 before the first element; incremented by <see cref="MoveNext"/>.
        /// Valid indices are 0..(<see cref="{{TYPE_NAME}}.Count"/> - 1).
        /// </summary>
        private int _index;

        /// <summary>
        /// Initializes a new <see cref="Enumerator"/> for the specified <paramref name="bits"/>.
        /// </summary>
        /// <param name="bits">The parent <see cref="{{TYPE_NAME}}"/> instance to enumerate.</param>
        /// <remarks>
        /// The constructor sets the internal index to -1 so enumeration starts before the first element.
        /// </remarks>
        internal Enumerator({{TYPE_NAME}} bits)
        {
            _bits = bits;
            _index = -1;
        }

        /// <summary>
        /// Advances the enumerator to the next bit.
        /// </summary>
        /// <returns><see langword="true"/> if the enumerator advanced to a valid bit; otherwise <see langword="false"/>.</returns>
        public bool MoveNext()
        {
            _index++;
            return _index < _bits.Count;
        }

        /// <summary>
        /// Gets the current bit value.
        /// </summary>
        public readonly bool Current => _bits[_index];
    }

    /// <summary>
    /// Interface implementation for <see cref="IEnumerable{Boolean}"/>.
    /// Enumerating via the interface will allocate (iterator state machine) and may box the struct.
    /// </summary>
    IEnumerator<bool> IEnumerable<bool>.GetEnumerator()
    {
        for (int i = 0; i < Count; i++)
        {
            yield return this[i];
        }
    }

    /// <inheritdoc/>
    IEnumerator IEnumerable.GetEnumerator() => ((IEnumerable<bool>)this).GetEnumerator();
}
